package com.sbkcastro.monitor.ui.charts

import android.app.Application
import android.content.Context
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.map
import androidx.lifecycle.viewModelScope
import com.sbkcastro.monitor.api.ApiClient
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import org.json.JSONObject

class ChartsProfessionalViewModel(application: Application) : AndroidViewModel(application) {

    private val _allMetrics = MutableLiveData<List<MetricPoint>>()
    private val _timeRange = MutableLiveData<TimeRange>(TimeRange.FOUR_HOURS)
    private val context = application.applicationContext

    val filteredMetrics: LiveData<List<MetricPoint>> = _timeRange.map { range ->
        filterMetricsByTimeRange(_allMetrics.value ?: emptyList(), range)
    }

    init {
        // Cargar historial guardado
        loadStoredMetrics()

        // Iniciar actualización automática cada 5 minutos
        startAutoUpdate()
    }

    fun setTimeRange(range: TimeRange) {
        _timeRange.value = range
    }

    fun addMetric(cpu: Float, ram: Float, disk: Float) {
        val currentList = _allMetrics.value ?: emptyList()
        val newMetric = MetricPoint(
            timestamp = System.currentTimeMillis(),
            cpuUsage = cpu,
            ramUsage = ram,
            diskUsage = disk
        )

        // Mantener últimas 24 horas de datos (asumiendo 1 punto cada 5 minutos = 288 puntos)
        val maxDataPoints = 288
        val updatedList = (currentList + newMetric).takeLast(maxDataPoints)

        _allMetrics.value = updatedList

        // Forzar actualización de filteredMetrics
        _timeRange.value = _timeRange.value
    }

    private fun filterMetricsByTimeRange(metrics: List<MetricPoint>, range: TimeRange): List<MetricPoint> {
        if (metrics.isEmpty()) return emptyList()

        val now = System.currentTimeMillis()
        val cutoffTime = now - (range.minutes * 60 * 1000)

        return metrics.filter { it.timestamp >= cutoffTime }
    }

    fun loadSampleData() {
        // Generar datos de muestra para testing
        val sampleMetrics = mutableListOf<MetricPoint>()
        val now = System.currentTimeMillis()

        // Generar 288 puntos (24 horas, cada 5 minutos)
        for (i in 287 downTo 0) {
            val timestamp = now - (i * 5 * 60 * 1000)
            val cpu = (10..80).random().toFloat() + (0..99).random() / 100f
            val ram = (20..90).random().toFloat() + (0..99).random() / 100f
            val disk = (50..75).random().toFloat() + (0..99).random() / 100f

            sampleMetrics.add(MetricPoint(timestamp, cpu, ram, disk))
        }

        _allMetrics.value = sampleMetrics
    }

    fun clearHistory() {
        _allMetrics.value = emptyList()
    }

    fun getMetricsCount(): Int {
        return _allMetrics.value?.size ?: 0
    }

    private fun startAutoUpdate() {
        viewModelScope.launch {
            while (true) {
                fetchRealMetrics()
                delay(5 * 60 * 1000) // 5 minutos
            }
        }
    }

    fun fetchRealMetrics() {
        viewModelScope.launch {
            try {
                val apiService = ApiClient.getService()
                val response = apiService.getMetrics()

                val cpu = response.cpu.usage
                val ram = response.memory.usagePercent
                val disk = parseDiskUsage(response.disk.usagePercent)

                addMetric(cpu, ram, disk)
                saveMetrics()
            } catch (e: Exception) {
                // Si falla, usar loadSampleData como fallback
                if (_allMetrics.value.isNullOrEmpty()) {
                    loadSampleData()
                }
            }
        }
    }

    private fun parseDiskUsage(diskString: String): Float {
        return try {
            diskString.replace("%", "").toFloat()
        } catch (e: Exception) {
            67f // Default
        }
    }

    private fun saveMetrics() {
        val prefs = context.getSharedPreferences("charts_data", Context.MODE_PRIVATE)
        val metrics = _allMetrics.value ?: return

        val json = JSONObject()
        val metricsArray = org.json.JSONArray()

        metrics.forEach { metric ->
            val metricJson = JSONObject().apply {
                put("timestamp", metric.timestamp)
                put("cpu", metric.cpuUsage)
                put("ram", metric.ramUsage)
                put("disk", metric.diskUsage)
            }
            metricsArray.put(metricJson)
        }

        json.put("metrics", metricsArray)
        prefs.edit().putString("metrics_data", json.toString()).apply()
    }

    private fun loadStoredMetrics() {
        val prefs = context.getSharedPreferences("charts_data", Context.MODE_PRIVATE)
        val jsonString = prefs.getString("metrics_data", null) ?: return

        try {
            val json = JSONObject(jsonString)
            val metricsArray = json.getJSONArray("metrics")
            val metricsList = mutableListOf<MetricPoint>()

            for (i in 0 until metricsArray.length()) {
                val metricJson = metricsArray.getJSONObject(i)
                metricsList.add(
                    MetricPoint(
                        timestamp = metricJson.getLong("timestamp"),
                        cpuUsage = metricJson.getDouble("cpu").toFloat(),
                        ramUsage = metricJson.getDouble("ram").toFloat(),
                        diskUsage = metricJson.getDouble("disk").toFloat()
                    )
                )
            }

            _allMetrics.value = metricsList
        } catch (e: Exception) {
            // Si falla al cargar, iniciar con datos vacíos
            _allMetrics.value = emptyList()
        }
    }
}
